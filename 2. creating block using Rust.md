We can't get to the greateness of blockchain by talking. A line of code is worth more than one thousand words, if we want to understand the power of blockchain, we need to code it out then you know the beauty of blockchain.
Let's code the shit out for blockchain. First we create a new project for it by using command:

```rs
cargo new blockchain
```

What we need to do is using code to implement the block structure like following:

![rust blockchain](https://github.com/user-attachments/assets/42aaf2de-c11f-4aff-9956-3298595fc3a0)

We need to use the struct from Rust to describe the block object aboved, The prev hash is actuall a hash result for given bytes array, therefore its type is byte array which in Rust is Vec<u8>, and the nonce is an integer which
is used to indicate the order of the block, and we can use data type of i32 to represent it, the timestamp is used to describe when the given block is created, usually we use 64 bits integer to represent a time unit, so we will
use u128 to represnt it, and finally the transactions is a collection of transaction, a transaction can be represented by bytes array, therefore transactions are a collection of bytes array. A byte array can be represented by
Vec<u8> in Rust, and collection of byte array can be represented as Vec<Vec<u8>>,therefore we have the following code:

```rs
struct Block {
    nonce: i32,
    previous_hash: Vec<u8>,
    time_stamp: u128,
    transactions: Vec<Vec<u8>>,
}
```
Pay attention to naming pattern in Rust, for name of Object or struct, we use CamelCase, and for field name or method name we use snak_case.

struct in Rust is just like struct in C or golang and class in c++, java, python, js, we can attach methods to struct just like methods for class. In Rust we wil use keyword impl such as following:
```rs
impl Block {
    //static method, it dosen't need to access to the struct
    //Self is alias name of the given struct, notice it should Capitalize
    fn new(nonce: i32, previous_hash: Vec<u8>) -> Self {
        let duration_since_epoch = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap();
        //notice the parameter of previous_hash will lost ownership
        Block {
            nonce: nonce,
            previous_hash: previous_hash,
            time_stamp: duration_since_epoch.as_nanos(),
            /*
            If the type for vector is complex one such as another kind of
            vector, then we need to have :: between Vec and its type <Vec<u8>>
            */
            transactions: Vec::<Vec<u8>>::new(),
        } //don't add semicolon here, since we want to return the object
    }

    //struct method, it will receive the reference of the struct instance
    fn print(&self) {
        /*
        If we won't change any fields in the strint, we use inmutable reference,
        otherwise we need mutable reference &mut self
        */
        //format hex value
        println!("timestamp: {:x}", self.time_stamp);
        //format integer value
        println!("nonce:      {},", self.nonce);
        //let compiler decide how to print vector
        //actually it is called trait, go to it later
        println!("previous_hash:    {:?}", self.previous_hash);
        println!("transactions:     {:?}", self.transactions);
    }
}

fn main() {
    //as_bytes convert string to bytes array
    let b = Block::new(0, "this is our first block!".to_string().into_bytes());
    b.print();
}
```

We have two types of methods that can attach to struct, one is what we call static, such methods won't reading or writing to fields in the struct and its not need the pointer for the instance of the given struct.We have one of
this method which is a constructor of the Block struct. The other methods are called struct method which needs to access to fields in the struct, and it need the pointer of the given struct instance, if it only need to read into
fields of the struct, it will need an inmutable reference, otherwise it need mutable reference.

When call struct methods, just like b.print, the compiler will send the reference instance to the method automatically, the other thing we need to notice is the Self keyword in struct, it is alias for the name of the struct. 
Benifits of using it is, when we change the name of the struct later on, we don't goto the code to change the old name. Running the code aboved will have the following result:

```rs
timestamp: 17eab0d1ae4019f0
nonce:      0,
previous_hash:    [116, 104, 105, 115, 32, 105, 115, 32, 111, 117, 114, 32, 102, 105, 114, 115, 116, 32, 98, 108, 111, 99, 107, 33]
transactions:     []
```
Actually, we can ask the compiler to print the Block object instead of writng a print method, as long as we add a directive like following:
```rs
#[derive(Debug)]
struct Block {
    nonce: i32,
    previous_hash: Vec<u8>,
    time_stamp: u128,
    transactions: Vec<Vec<u8>>,
}
```
Then we can use the "{:?}" to format and print out the object such as:
```rs
fn main() {
    //as_bytes convert string to bytes array
    let b = Block::new(0, "this is our first block!".to_string().into_bytes());
    b.print();

    println!("the first block is : {:?}", b);
}
```
Running aboved code will have following result:
```rs
timestamp: 17eab1c4d8dd34b0
nonce:      0,
previous_hash:    [116, 104, 105, 115, 32, 105, 115, 32, 111, 117, 114, 32, 102, 105, 114, 115, 116, 32, 98, 108, 111, 99, 107, 33]
transactions:     []
the first block is : Block { nonce: 0, previous_hash: [116, 104, 105, 115, 32, 105, 115, 32, 111, 117, 114, 32, 102, 105, 114, 115, 116, 32, 98, 108, 111, 99, 107, 33], time_stamp: 1723385266432718000, transactions: [] }
```
Such mechanism is called trait in Rust and is very powerful but not easy to understand, we will goto it in detail in later sections
