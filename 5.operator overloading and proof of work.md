In this section, we will go to know operator overloading of Rust and how we use it to implement the proof of work for blockchain. Proof of work is used to prevent cheating from nodes of blockchain. For example if you
save 100 dollar on the chain, then this amount will record in a transaction and save to a block in the chain, and every node will synchronize the chain for data consitency. If some of the nodes want to change your 
saving amount from 100 to 50, then blockchain need some mechanism to prevent such evil doing.

The way for solving this is, when transactions add to a block, it need to do some heavy work to compute a hash value, this value can verify easily by other nodes. If one of node change contents in transactions, the
hash value of the block will be changed completely and other nodes can be notified easily and the cheating node will be excluded from the chain. The algorithm for computing hash value is like following:

![rust blockchain](https://github.com/user-attachments/assets/c7deb7c1-54ba-4a29-874d-2f34802e93ad)


A block contains four fields: nonce, previous hash, timestamp, nonce. When computing the hash value, we set the timestamp and nonce to 0, then we combine then together for hash256 hash. And there is a value called
difficulty which is a number, if the computed hash value has given number of 0 indicated by the difficulty  at the beginning, then the proof of work is complete the block can add to the chain, if not, we need to 
change the value and try again, this process will repeat until the hash value meet the requirement.

We already has method to compute the given block hash, the point is if the hash value dosen't meet the diffuclty, then we will increase the value of nonce and try again, we can easy do this by:
```rs
block.nonce += 1;
```
Since we are learning Rust and blockchain at the same time, we can do it by a fancy way which is operator overloading, that is we want to do following:

```rs
block += 1;
```
By using aboved code we can make sure value 1 is add to the nonce field. Operator overloading actually is a kind of trait we have seen before, the operator += is component operator, it is trait is defined as following:
```rs
trait AddAssign<Rhs = Self> {
    fn add_assign(&mut self, rhs: Rhs);
}
```
In aboved trait defined, Rhs is the type at the right of +=, it is by default to be the same type as left, but according to our need, Rhs need to be i32, since the type of nonce is i32, this trait is from module 
std::ops::AddAssign, let's try to implement the trait as following code in mod.rs:

```rs
impl AddAssign<i32> for Block {
    fn add_assign(&mut self, rhs: i32) {
        self.nonce += rhs;
    }
}
```

Then in main.rs we have following code:
```rs
fn main() {
    let mut block = Block::new(0, "previous hash".as_bytes().to_vec());
    println!("blcok before += 1: {:?}", block);
    block += 1;
    println!("block after += 1: {:?}", block);
}
```
Running aboved code we get the following output:
```rs
blcok before += 1: Block { nonce: 0, previous_hash: [112, 114, 101, 118, 105, 111, 117, 115, 32, 104, 97, 115, 104], time_stamp: 1724900728074263000, transactions: [] }
block after += 1: Block { nonce: 1, previous_hash: [112, 114, 101, 118, 105, 111, 117, 115, 32, 104, 97, 115, 104], time_stamp: 1724900728074263000, transactions: [] }
``` 
Notice that the nonce field is increased from 0 to 1. Now let's see how we do the proof of work as following:
```rs
pub fn create_block(&mut self, nonce: i32, previous_hash: Vec<u8>) {
        let mut b = Block::new(nonce, previous_hash);

        for tx in self.transaction_pool.iter() {
            b.transactions.push(tx.clone());
        }
        self.transaction_pool.clear();

        //do proof of work
        let now = Instant::now();
        let proof_hash = BlockChain::do_proof_of_work(&mut b);
        let elapsed = now.elapsed();
        println!(
            "computing time: {:?},proof hash for current block is: {:?}",
            elapsed, proof_hash
        );

        //the chain own the block
        self.chain.push(b);
    }

 fn do_proof_of_work(block: &mut Block) -> String {
        loop {
            let hash = block.hash();
            let hash_str = hex::encode(&hash);
            if hash_str[0..BlockChain::DIFFICULTY] == "0".repeat(BlockChain::DIFFICULTY) {
                return hash_str;
            }

            *block += 1;
        }
    }
```
After adding aboved code, we can test the code in main.rs as following:

```rs
fn main() {
    let mut block_chain = BlockChain::new();
    block_chain.print();
}
```

Then run the code and we get the following result:
```rs
compute time: 103.300221ms
proof for the current block is :"0004794c524ef2583cb02e77408b7c889823afc9e678aaa3b327c70ce05b36ec"
========================= Chain 0 =========================
timestamp: 17f03fe0dad70200
nonce: 2689
previous_hash: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
transactions: []
*************************
```
you can try to increase the difficulty level and found time used to compute the proof of work will get longer and longer.
