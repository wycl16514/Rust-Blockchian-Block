In this section, we will go to know operator overloading of Rust and how we use it to implement the proof of work for blockchain. Proof of work is used to prevent cheating from nodes of blockchain. For example if you
save 100 dollar on the chain, then this amount will record in a transaction and save to a block in the chain, and every node will synchronize the chain for data consitency. If some of the nodes want to change your 
saving amount from 100 to 50, then blockchain need some mechanism to prevent such evil doing.

The way for solving this is, when transactions add to a block, it need to do some heavy work to compute a hash value, this value can verify easily by other nodes. If one of node change contents in transactions, the
hash value of the block will be changed completely and other nodes can be notified easily and the cheating node will be excluded from the chain. The algorithm for computing hash value is like following:

![rust blockchain](https://github.com/user-attachments/assets/c7deb7c1-54ba-4a29-874d-2f34802e93ad)


A block contains four fields: nonce, previous hash, timestamp, nonce. When computing the hash value, we set the timestamp and nonce to 0, then we combine then together for hash256 hash. And there is a value called
difficulty which is a number, if the computed hash value has given number of 0 indicated by the difficulty  at the beginning, then the proof of work is complete the block can add to the chain, if not, we need to 
change the value and try again, this process will repeat until the hash value meet the requirement.

We already has method to compute the given block hash, the point is if the hash value dosen't meet the diffuclty, then we will increase the value of nonce and try again, we can easy do this by:
```rs
block.nonce += 1;
```
Since we are learning Rust and blockchain at the same time, we can do it by a fancy way which is operator overloading, that is we want to do following:

```rs
block += 1;
```
By using aboved code we can make sure value 1 is add to the nonce field. Operator overloading actually is a kind of trait we have seen before, the operator += is component operator, it is trait is defined as following:
```rs
trait AddAssign<Rhs = Self> {
    fn add_assign(&mut self, rhs: Rhs);
}
```
In aboved trait defined, Rhs is the type at the right of +=, it is by default to be the same type as left, but according to our need, Rhs need to be i32, since the type of nonce is i32, this trait is from module 
std::ops::AddAssign, let's try to implement the trait as following code in mod.rs:

```rs
impl AddAssign<i32> for Block {
    fn add_assign(&mut self, rhs: i32) {
        self.nonce += rhs;
    }
}
```

Then in main.rs we have following code:
```rs
fn main() {
    let mut block = Block::new(0, "previous hash".as_bytes().to_vec());
    println!("blcok before += 1: {:?}", block);
    block += 1;
    println!("block after += 1: {:?}", block);
}
```
Running aboved code we get the following output:
```rs
blcok before += 1: Block { nonce: 0, previous_hash: [112, 114, 101, 118, 105, 111, 117, 115, 32, 104, 97, 115, 104], time_stamp: 1724900728074263000, transactions: [] }
block after += 1: Block { nonce: 1, previous_hash: [112, 114, 101, 118, 105, 111, 117, 115, 32, 104, 97, 115, 104], time_stamp: 1724900728074263000, transactions: [] }
``` 
Notice that the nonce field is increased from 0 to 1. Now let's see how we do the proof of work as following:
```rs
pub fn create_block(&mut self, nonce: i32, previous_hash: Vec<u8>) {
        let mut b = Block::new(nonce, previous_hash);

        for tx in self.transaction_pool.iter() {
            b.transactions.push(tx.clone());
        }
        self.transaction_pool.clear();

        //do proof of work
        let now = Instant::now();
        let proof_hash = BlockChain::do_proof_of_work(&mut b);
        let elapsed = now.elapsed();
        println!(
            "computing time: {:?},proof hash for current block is: {:?}",
            elapsed, proof_hash
        );

        //the chain own the block
        self.chain.push(b);
    }

 fn do_proof_of_work(block: &mut Block) -> String {
        loop {
            let hash = block.hash();
            let hash_str = hex::encode(&hash);
            if hash_str[0..BlockChain::DIFFICULTY] == "0".repeat(BlockChain::DIFFICULTY) {
                return hash_str;
            }

            *block += 1;
        }
    }
```
After adding aboved code, we can test the code in main.rs as following:

```rs
fn main() {
    let mut block_chain = BlockChain::new();
    block_chain.print();
}
```

Then run the code and we get the following result:
```rs
compute time: 103.300221ms
proof for the current block is :"0004794c524ef2583cb02e77408b7c889823afc9e678aaa3b327c70ce05b36ec"
========================= Chain 0 =========================
timestamp: 17f03fe0dad70200
nonce: 2689
previous_hash: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
transactions: []
*************************
```
you can try to increase the difficulty level and found time used to compute the proof of work will get longer and longer.

Let's have another look for operator overloading. What about we want to compare two block objects by using "==", then we need to overload this compound operator as 
following:

```js
trait PartialEq<Rhs=Self> where Rhs :? Sized {
    fn eq(&self, other: &Rhs) -> bool;
    fn eq(&self, other: &Rhs) -> bool {
        !self.eq(other)
    }
}
```
There are many things need to be noticed, The first is ?Sized, Sized is an important concept for Rust, All concret type like Block, BlockChain are Sized, because the 
compiler can know how many memory is used by the given objects. And all trait like Serialization is not sized, because the compiler would not know the memory size for
given object at the compile time, we will goto it in later sections.

The second thing need to be noticed is, eventhought there are two methods in the trait, we only need to implement the method of eq. 

The third one we need to be noticed is, the trait for "==" is called Partial Equal, why it is partial? That's because for given object x, "x == x" may not be true, for 
example, NaN is a object of "not a number", and it is not equal to any value even to itself.

If we want to compare two Block object are equal or not, we can implement this trait on Block, and in the eq method, we can compare their hash value for equalization:
in mod.rs, we have following code:
```rs
use std::cmp::PartialEq;
impl PartialEq for Block {
    fn eq(&self, other: &Block) -> bool {
        let self_hash = self.hash();
        let other_hash = other.hash();
        self_hash == other_hash
    }
}
```
Then we in main.rs:
```rs
fn main() {
    let mut block1 = Block::new(0, "previous hash".as_bytes().to_vec());
    let mut block2 = Block::new(0, "previous hash".as_bytes().to_vec());
    println!("block1 == block2 : {}", block1 == block2);
}
```
Then we have following result:
```rs
block1 == block2 : false
```
Since the time stamp of two blocks are different, therefore they have two different hash value. Another interesting operator is "[]" which is the index operator, Since
we put blocks in a vector, then for BlockChain object block_chain, we want to get given block in given index as block_chain[1], then we can overload the following trait:

```rs
trait Index<idx> {
    type Output: ?Sized;
    fn index(&self, index: Idx) -> &Self::Output;
}
```
Let's see how we can implement this trait by code:

```rs
impl Index<usize> for BlockChain {
    type Output = Block;
    fn index(&self, idx: usize) -> &Self::Output {
        let res = self.chain.get(idx);
        match res {
            Some(block) => {
                return block;
            }
            None => {
                panic!("index out of range for the chain");
            }
        }
    }
}
```

Then in main.rs we have:
```rs
fn main() {
    let block = block_chain[0];
    println!("The first block of the chain is: {:?}", block);
}
```
Then running the code we get the following result:
```rs
The first block of the chain is: Block { nonce: 19446, previous_hash: [227, 213, 239, 160, 56, 197, 155, 104, 95, 24, 112, 186, 143, 78, 130, 186, 194, 212, 64, 40, 220, 244, 241, 25, 0, 192, 14, 110, 141, 147, 98, 110], time_stamp: 1725009702018728000, transactions: [] }
```
